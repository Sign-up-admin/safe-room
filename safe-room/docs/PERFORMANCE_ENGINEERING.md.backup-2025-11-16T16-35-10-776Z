# 压力与并发工程（软件性能工程）总章

> 本文档聚焦 `safe-room` 健身房综合管理系统的性能工程实践，涵盖压力测试、并发控制、性能监控、优化策略等核心主题。内容与 `docs/ARCHITECTURE.md`、`docs/BEST_PRACTICES.md` 等文档相互关联，旨在建立统一的性能工程标准。

---

## 文档使用方式

- **参考顺序**：按章节顺序阅读，或根据具体需求（压力测试、性能优化、容量规划）直接查阅对应章节。
- **关联文档**：遇到"详见"或相对路径时，优先阅读对应文档以了解实现细节。
- **落地要求**：进行性能测试、优化或容量规划时，需参考本文档并在 PR 描述中说明遵循了哪些实践。

---

## 目录

1. [性能工程概述](#第一章-性能工程概述)
2. [压力测试基础](#第二章-压力测试基础)
3. [并发控制机制](#第三章-并发控制机制)
4. [性能监控与诊断](#第四章-性能监控与诊断)
5. [性能优化策略](#第五章-性能优化策略)
6. [分布式系统性能](#第六章-分布式系统性能)
7. [性能测试实践](#第七章-性能测试实践)
8. [容量规划](#第八章-容量规划)

---

## 第一章：性能工程概述

### 1.1 性能工程的定义与重要性

性能工程（Performance Engineering）是软件工程的一个分支，专注于在软件开发生命周期的各个阶段确保系统满足性能需求。与传统的性能测试（在开发完成后进行）不同，性能工程强调从设计阶段就开始考虑性能问题。

**核心价值**：
- **预防性**：在问题出现前识别和解决性能瓶颈
- **持续性**：贯穿整个软件开发生命周期
- **系统性**：综合考虑架构、代码、数据库、网络等各个层面
- **可量化**：基于指标和数据进行决策

**对 safe-room 系统的意义**：
- 确保课程预约、支付等关键业务在高并发场景下的稳定性
- 优化用户体验，减少页面加载时间和响应延迟
- 降低服务器资源成本，提高系统资源利用率
- 为业务增长提供可扩展的技术基础

### 1.2 性能指标体系

#### 1.2.1 响应时间（Response Time）
- **定义**：从发起请求到收到响应的时间
- **分类**：
  - 前端响应时间：页面加载、交互响应
  - 后端响应时间：API 接口处理时间
  - 数据库响应时间：SQL 查询执行时间
- **目标**：
  - 页面首屏加载：< 2 秒
  - API 接口响应：< 500ms（P95）
  - 数据库查询：< 100ms（简单查询）

#### 1.2.2 吞吐量（Throughput）
- **定义**：单位时间内系统处理的请求数量
- **指标**：
  - QPS（Queries Per Second）：每秒查询数
  - TPS（Transactions Per Second）：每秒事务数
  - RPS（Requests Per Second）：每秒请求数
- **目标**：根据业务需求设定，如课程列表接口 ≥ 1000 QPS

#### 1.2.3 并发数（Concurrency）
- **定义**：同时处理请求的用户数或连接数
- **类型**：
  - 并发用户数：同时在线用户
  - 并发连接数：同时建立的网络连接
  - 并发线程数：同时执行的线程
- **监控**：数据库连接池、应用线程池、HTTP 连接数

#### 1.2.4 资源利用率（Resource Utilization）
- **CPU 使用率**：建议 < 70%（峰值）
- **内存使用率**：建议 < 80%
- **磁盘 I/O**：监控读写速率和队列深度
- **网络带宽**：监控入站/出站流量

### 1.3 性能工程生命周期

```
需求分析 → 架构设计 → 开发实现 → 性能测试 → 性能调优 → 上线监控 → 持续优化
    ↓          ↓          ↓          ↓          ↓          ↓          ↓
  性能需求   性能设计   代码审查   压力测试   瓶颈分析   性能监控   容量规划
```

**各阶段要点**：
1. **需求分析**：明确性能目标（响应时间、吞吐量、并发数）
2. **架构设计**：选择合适的技术栈、设计可扩展架构（参考 `docs/ARCHITECTURE.md`）
3. **开发实现**：遵循性能最佳实践（参考 `docs/BEST_PRACTICES.md`）
4. **性能测试**：定期进行压力测试和性能回归测试
5. **性能调优**：识别瓶颈并优化（代码、数据库、架构）
6. **上线监控**：建立性能监控体系，设置告警阈值
7. **持续优化**：基于监控数据持续改进

---

## 第二章：压力测试基础

### 2.1 压力测试概念与目标

压力测试（Stress Testing）是通过模拟超出正常负载的场景，测试系统在极限条件下的表现，以发现系统的瓶颈和潜在问题。

**测试目标**：
- **发现瓶颈**：识别系统在高压下的性能瓶颈点
- **验证稳定性**：确保系统在极限负载下不会崩溃
- **评估容量**：确定系统的最大承载能力
- **验证恢复能力**：测试系统在压力释放后的恢复能力

**测试场景**：
- 课程预约高峰期（如新课程上线、促销活动）
- 支付高峰期（会员续费、课程购买）
- 系统启动时的瞬时流量冲击

### 2.2 压力测试类型

#### 2.2.1 负载测试（Load Testing）
- **定义**：在预期负载下测试系统性能
- **目标**：验证系统在正常负载下是否满足性能要求
- **示例**：模拟 100 个并发用户同时浏览课程列表

#### 2.2.2 压力测试（Stress Testing）
- **定义**：逐步增加负载，直到系统达到性能极限
- **目标**：找出系统的最大承载能力
- **示例**：从 100 并发逐步增加到 1000 并发，观察系统表现

#### 2.2.3 峰值测试（Spike Testing）
- **定义**：突然增加大量负载，测试系统的抗冲击能力
- **目标**：验证系统能否处理突发流量
- **示例**：瞬间从 100 并发增加到 500 并发

#### 2.2.4 容量测试（Capacity Testing）
- **定义**：测试系统在特定负载下能处理的最大数据量
- **目标**：确定系统的容量上限，为扩容提供依据
- **示例**：测试系统能同时处理多少条课程预约记录

### 2.3 压力测试工具

#### 2.3.1 JMeter
- **特点**：开源、功能强大、支持多种协议
- **适用场景**：HTTP/HTTPS API 压力测试
- **优势**：
  - 图形化界面，易于使用
  - 支持分布式测试
  - 丰富的报告和图表
- **使用示例**：
  ```xml
  <!-- JMeter 测试计划示例 -->
  <TestPlan>
    <ThreadGroup>
      <numThreads>100</numThreads>
      <rampUp>10</rampUp>
      <duration>300</duration>
    </ThreadGroup>
    <HTTPSampler>
      <domain>localhost</domain>
      <port>8080</port>
      <path>/springboot1ngh61a2/jianshenkecheng/list</path>
    </HTTPSampler>
  </TestPlan>
  ```

#### 2.3.2 Gatling
- **特点**：基于 Scala，性能优秀，支持代码化测试脚本
- **适用场景**：高性能压力测试，CI/CD 集成
- **优势**：
  - 高并发性能好
  - 测试脚本可版本控制
  - 详细的 HTML 报告

#### 2.3.3 Locust
- **特点**：基于 Python，支持分布式，易于扩展
- **适用场景**：需要自定义测试逻辑的场景
- **优势**：
  - 测试脚本用 Python 编写，灵活
  - Web UI 实时监控
  - 支持分布式执行

#### 2.3.4 K6
- **特点**：基于 JavaScript，现代化设计，适合 CI/CD
- **适用场景**：持续集成中的性能测试
- **优势**：
  - 脚本用 JavaScript 编写
  - 性能优秀
  - 易于集成到 CI/CD 流程

#### 2.3.5 工具选择建议

| 工具 | 适用场景 | 学习曲线 | 性能 |
|------|---------|---------|------|
| JMeter | 快速上手、GUI 操作 | 低 | 中等 |
| Gatling | 高性能、CI/CD | 中 | 高 |
| Locust | 灵活定制 | 中 | 高 |
| K6 | 现代化、CI/CD | 低 | 高 |

**推荐**：对于 safe-room 项目，建议使用 JMeter 进行初步测试，使用 Gatling 或 K6 进行持续集成中的自动化性能测试。

---

## 第三章：并发控制机制

### 3.1 并发模型

#### 3.1.1 线程模型
- **定义**：使用操作系统线程实现并发
- **特点**：
  - 线程共享进程内存空间
  - 线程切换开销较大
  - 适合 CPU 密集型任务
- **Java 实现**：`java.util.concurrent` 包提供线程池、并发集合等工具
- **Spring Boot 应用**：默认使用 Tomcat 线程池处理 HTTP 请求

**safe-room 项目配置**：
- Spring Boot 3.x 默认使用内嵌 Tomcat，线程池配置可通过 `application.yml` 调整：
  ```yaml
  server:
    tomcat:
      threads:
        max: 200          # 最大工作线程数（默认200）
        min-spare: 10     # 最小空闲线程数（默认10）
      max-connections: 10000  # 最大连接数
      accept-count: 100   # 等待队列长度
      connection-timeout: 20000  # 连接超时时间（毫秒）
  ```
- 生产环境建议根据实际负载调整，监控线程池使用情况

#### 3.1.2 进程模型
- **定义**：使用多个进程实现并发
- **特点**：
  - 进程间内存隔离
  - 进程间通信开销大
  - 适合需要隔离的场景
- **应用**：多实例部署、微服务架构

#### 3.1.3 协程模型
- **定义**：用户态轻量级线程
- **特点**：
  - 切换开销小
  - 适合 I/O 密集型任务
  - 需要语言或框架支持
- **应用**：Go 语言的 goroutine、Kotlin 的 coroutine

#### 3.1.4 异步 I/O 模型
- **定义**：基于事件循环的异步非阻塞 I/O
- **特点**：
  - 高并发性能好
  - 编程模型复杂
  - 适合高并发 I/O 场景
- **应用**：Node.js、Netty、Spring WebFlux

### 3.2 限流与并发控制

#### 3.2.1 接口限流（Rate Limiting）

**safe-room 项目限流实现**：

项目使用 `RateLimitInterceptor` 实现基于 IP 的接口限流，防止暴力破解和 DDoS 攻击。

**实现位置**：`com.interceptor.RateLimitInterceptor`

**限流策略**：
```java
// 登录接口限流：5次/分钟
private static final double LOGIN_RATE = 5.0;

// 注册接口限流：3次/分钟
private static final double REGISTER_RATE = 3.0;

// 密码重置接口限流：2次/分钟
private static final double RESET_PASSWORD_RATE = 2.0;
```

**技术实现**：
- 使用 Guava 的 `RateLimiter` 实现令牌桶算法
- 使用 `CacheBuilder` 为每个 IP 维护独立的限流器
- 自动过期清理，避免内存泄漏

**拦截器配置**（`InterceptorConfig.java`）：
```java
@Override
public void addInterceptors(InterceptorRegistry registry) {
    // 速率限制拦截器（优先级高，先执行）
    if (rateLimitInterceptor != null && !isTestProfile()) {
        registry.addInterceptor(rateLimitInterceptor)
                .addPathPatterns("/**")
                .excludePathPatterns("/static/**");
    }
    // ...
}
```

**限流响应**：
- 状态码：429 (Too Many Requests)
- 响应格式：`{"code": 429, "msg": "登录请求过于频繁，请稍后再试"}`

**扩展建议**：
- 可扩展为基于用户ID的限流（登录后）
- 可集成 Redis 实现分布式限流（多实例部署）
- 可添加滑动窗口限流算法支持更复杂的限流策略

### 3.3 锁机制

#### 3.3.1 悲观锁（Pessimistic Locking）
- **原理**：假设会发生冲突，先加锁再操作
- **实现**：
  - 数据库：`SELECT ... FOR UPDATE`
  - Java：`synchronized`、`ReentrantLock`
- **适用场景**：冲突频繁的场景
- **示例**：课程预约时锁定课程名额
  ```java
  // 使用数据库悲观锁
  @Transactional
  public void bookCourse(Long courseId, Long userId) {
      Course course = courseDao.selectById(courseId);
      // 锁定记录
      course = courseDao.selectByIdForUpdate(courseId);
      if (course.getRemainingSeats() > 0) {
          course.setRemainingSeats(course.getRemainingSeats() - 1);
          courseDao.updateById(course);
          // 创建预约记录
          createBooking(courseId, userId);
      } else {
          throw new RRException("课程已满");
      }
  }
  ```

#### 3.3.2 乐观锁（Optimistic Locking）
- **原理**：假设不会发生冲突，通过版本号或时间戳检测冲突
- **实现**：
  - 数据库：版本字段 + `WHERE version = ?`
  - Java：`AtomicInteger`、`CAS` 操作
- **适用场景**：冲突较少的场景，读多写少
- **示例**：使用版本号实现乐观锁
  ```java
  // 实体类添加版本字段
  @TableName("jianshenkecheng")
  public class Course {
      @Version
      private Integer version;
      // ...
  }
  
  // 更新时自动检查版本
  public void updateCourse(Course course) {
      int rows = courseDao.updateById(course);
      if (rows == 0) {
          throw new RRException("数据已被修改，请刷新后重试");
      }
  }
  ```

#### 3.3.3 分布式锁
- **原理**：在分布式环境下实现互斥访问
- **实现方式**：
  - **Redis**：使用 `SET NX EX` 命令
  - **Zookeeper**：使用临时顺序节点
  - **数据库**：使用唯一索引
- **适用场景**：分布式系统、多实例部署
- **示例**：使用 Redis 实现分布式锁
  ```java
  // 使用 Redis 分布式锁
  public boolean tryLock(String key, String value, long expireTime) {
      Boolean result = redisTemplate.opsForValue()
          .setIfAbsent(key, value, expireTime, TimeUnit.SECONDS);
      return Boolean.TRUE.equals(result);
  }
  
  public void releaseLock(String key, String value) {
      String script = "if redis.call('get', KEYS[1]) == ARGV[1] then " +
                      "return redis.call('del', KEYS[1]) else return 0 end";
      redisTemplate.execute(new DefaultRedisScript<>(script, Long.class),
                           Collections.singletonList(key), value);
  }
  ```

### 3.4 并发数据结构与算法

#### 3.4.1 并发集合
- **ConcurrentHashMap**：线程安全的 HashMap
- **CopyOnWriteArrayList**：读多写少的场景
- **BlockingQueue**：生产者-消费者模式
- **ConcurrentLinkedQueue**：无锁队列

#### 3.4.2 线程池
- **ThreadPoolExecutor**：Java 标准线程池
- **配置参数**：
  - `corePoolSize`：核心线程数
  - `maximumPoolSize`：最大线程数
  - `keepAliveTime`：空闲线程存活时间
  - `workQueue`：任务队列
- **Spring Boot 配置**：参考 `docs/BEST_PRACTICES.md` 中的连接池配置

#### 3.4.3 无锁编程
- **CAS（Compare-And-Swap）**：原子操作
- **应用**：`AtomicInteger`、`AtomicLong`、`AtomicReference`
- **优势**：避免锁竞争，性能好
- **劣势**：可能出现 ABA 问题，需要处理

### 3.5 死锁预防与检测

#### 3.5.1 死锁产生条件
1. **互斥条件**：资源不能被多个线程同时使用
2. **请求与保持**：持有资源的同时请求其他资源
3. **不可剥夺**：资源不能被强制释放
4. **循环等待**：形成资源请求的环形链

#### 3.5.2 死锁预防策略
- **避免嵌套锁**：尽量减少锁的嵌套层级
- **锁顺序**：统一锁的获取顺序
- **超时机制**：使用 `tryLock(timeout)` 避免无限等待
- **锁粒度**：减小锁的粒度，使用细粒度锁

#### 3.5.3 死锁检测
- **JVM 工具**：`jstack` 查看线程堆栈
- **监控工具**：APM 工具可以检测死锁
- **日志分析**：记录锁的获取和释放，分析死锁

#### 3.5.4 最佳实践
```java
// 避免死锁的示例：统一锁顺序
public void transfer(Long fromId, Long toId, BigDecimal amount) {
    Long firstLock = fromId < toId ? fromId : toId;
    Long secondLock = fromId < toId ? toId : fromId;
    
    synchronized (firstLock) {
        synchronized (secondLock) {
            // 执行转账逻辑
            accountService.debit(fromId, amount);
            accountService.credit(toId, amount);
        }
    }
}
```

---

## 第四章：性能监控与诊断

### 4.1 性能监控指标

#### 4.1.1 CPU 监控
- **指标**：CPU 使用率、CPU 负载、上下文切换次数
- **工具**：`top`、`htop`、`vmstat`、`sar`
- **告警阈值**：CPU 使用率 > 70% 持续 5 分钟
- **分析**：识别 CPU 密集型操作，优化算法或增加缓存

#### 4.1.2 内存监控
- **指标**：内存使用率、堆内存、非堆内存、GC 频率
- **工具**：`free`、`jstat`、`jmap`、JVM 监控工具
- **告警阈值**：内存使用率 > 80%
- **分析**：识别内存泄漏，优化对象创建和回收

#### 4.1.3 磁盘 I/O 监控
- **指标**：磁盘使用率、读写速率、I/O 等待时间、队列深度
- **工具**：`iostat`、`iotop`、`df`
- **告警阈值**：磁盘使用率 > 85%，I/O 等待时间 > 100ms
- **分析**：优化数据库查询，使用 SSD，增加缓存

#### 4.1.4 网络监控
- **指标**：网络带宽、连接数、丢包率、延迟
- **工具**：`netstat`、`ss`、`iftop`、`tcpdump`
- **告警阈值**：带宽使用率 > 80%，连接数异常增长
- **分析**：优化数据传输，使用 CDN，压缩响应

### 4.2 APM 工具（Application Performance Monitoring）

#### 4.2.1 开源 APM 工具
- **Pinpoint**：Java 应用性能监控，支持分布式追踪
- **SkyWalking**：分布式系统性能监控，支持多种语言
- **Zipkin**：分布式追踪系统，轻量级
- **Jaeger**：云原生分布式追踪系统

#### 4.2.2 商业 APM 工具
- **New Relic**：功能全面，支持多种技术栈
- **Datadog**：云监控平台，集成度高
- **AppDynamics**：企业级 APM 解决方案

#### 4.2.3 APM 核心功能
- **分布式追踪**：追踪请求在微服务间的调用链
- **性能分析**：识别慢请求、慢 SQL、慢方法
- **错误追踪**：记录异常和错误堆栈
- **业务指标**：自定义业务指标监控

### 4.3 日志分析与性能分析工具

#### 4.3.1 日志分析
- **ELK Stack**：Elasticsearch + Logstash + Kibana
- **Loki**：轻量级日志聚合系统
- **Splunk**：企业级日志分析平台
- **日志格式**：结构化日志（JSON），包含 traceId、userId、耗时等字段

#### 4.3.2 性能分析工具
- **JProfiler**：Java 性能分析工具
- **VisualVM**：JVM 监控和分析工具
- **Arthas**：阿里巴巴开源的 Java 诊断工具
- **火焰图**：可视化性能瓶颈

### 4.4 性能瓶颈识别方法

#### 4.4.1 响应时间分析
- **前端时间**：DNS 解析、TCP 连接、SSL 握手、首字节时间
- **后端时间**：Controller 处理、Service 逻辑、数据库查询
- **工具**：浏览器 DevTools、APM 工具、日志分析

#### 4.4.2 数据库性能分析
- **慢查询日志**：PostgreSQL 的 `log_min_duration_statement`
- **执行计划**：`EXPLAIN ANALYZE` 分析查询计划
- **索引使用**：检查索引是否被使用
- **连接池监控**：监控连接池使用情况（参考 `docs/BEST_PRACTICES.md`）

#### 4.4.3 代码性能分析
- **方法耗时**：使用 APM 工具或 AOP 记录方法执行时间
- **热点代码**：使用性能分析工具找出 CPU 热点
- **内存分析**：使用内存分析工具找出内存泄漏

---

## 第五章：性能优化策略

### 5.1 代码层面优化

#### 5.1.1 算法优化
- **时间复杂度**：选择更高效的算法（如哈希表替代线性查找）
- **空间复杂度**：减少内存使用，避免不必要的对象创建
- **示例**：使用 `HashMap` 替代 `List` 进行查找操作

#### 5.1.2 数据结构选择
- **集合选择**：根据场景选择合适的集合类型
  - `ArrayList`：随机访问频繁
  - `LinkedList`：插入删除频繁
  - `HashMap`：快速查找
  - `TreeMap`：需要排序
- **避免过度设计**：简单场景使用简单数据结构

#### 5.1.3 代码优化技巧
- **避免不必要的对象创建**：使用对象池、复用对象
- **减少方法调用开销**：内联小方法、减少反射调用
- **优化循环**：减少循环嵌套、提前退出
- **使用 StringBuilder**：字符串拼接使用 `StringBuilder`

### 5.2 架构层面优化

#### 5.2.1 缓存策略
- **本地缓存**：Caffeine、Guava Cache
- **分布式缓存**：Redis、Memcached
- **缓存策略**：
  - **Cache-Aside**：应用先查缓存，未命中再查数据库
  - **Write-Through**：同时更新缓存和数据库
  - **Write-Behind**：先更新缓存，异步更新数据库
- **缓存失效**：设置合理的 TTL，使用缓存预热

#### 5.2.2 CDN（Content Delivery Network）
- **静态资源**：图片、CSS、JS 文件使用 CDN
- **优势**：减少服务器负载，提高访问速度
- **配置**：前端资源部署到 CDN，配置缓存策略

#### 5.2.3 负载均衡
- **类型**：
  - **轮询**：依次分配请求
  - **加权轮询**：根据服务器性能分配
  - **最少连接**：分配给连接数最少的服务器
  - **IP 哈希**：根据客户端 IP 分配
- **实现**：Nginx、HAProxy、云负载均衡器

#### 5.2.4 数据库优化
- **索引优化**：为常用查询字段建立索引，避免过多索引
- **查询优化**：避免 `SELECT *`，使用分页，优化 JOIN
- **连接池优化**：合理配置连接池大小（参考 `docs/BEST_PRACTICES.md`）
- **读写分离**：主从复制，读操作走从库
- **分库分表**：数据量大时考虑分库分表

**safe-room 项目 HikariCP 配置**：

开发环境（`application.yml`）：
```yaml
spring:
  datasource:
    hikari:
      minimum-idle: 5              # 最小空闲连接数
      maximum-pool-size: 20        # 最大连接池大小
      auto-commit: true
      idle-timeout: 30000          # 空闲连接超时时间（毫秒）
      pool-name: FitnessGymHikariCP
      max-lifetime: 1800000        # 连接最大生命周期（毫秒，30分钟）
      connection-timeout: 30000    # 连接超时时间（毫秒）
      connection-test-query: SELECT 1
```

生产环境（`application-prod.yml`）：
```yaml
spring:
  datasource:
    hikari:
      minimum-idle: ${DB_POOL_MIN_IDLE:10}      # 默认10
      maximum-pool-size: ${DB_POOL_MAX_SIZE:50} # 默认50
      idle-timeout: 300000                      # 5分钟
      leak-detection-threshold: 60000           # 连接泄漏检测阈值（毫秒）
      # 其他配置同开发环境
```

**配置说明**：
- `minimum-idle`：保持的最小空闲连接数，避免连接创建开销
- `maximum-pool-size`：最大连接数，建议设置为：`(核心数 * 2) + 有效磁盘数`
- `leak-detection-threshold`：生产环境建议启用，检测连接泄漏
- 连接池大小计算公式：`连接数 = ((核心数 * 2) + 有效磁盘数)`

### 5.3 系统层面优化

#### 5.3.1 JVM 调优
- **堆内存设置**：`-Xms`、`-Xmx` 设置初始和最大堆内存
- **GC 选择**：
  - **G1 GC**：大堆内存、低延迟要求
  - **Parallel GC**：吞吐量优先
  - **ZGC**：超大堆内存、极低延迟
- **GC 参数调优**：根据应用特点调整 GC 参数
- **监控**：使用 `jstat`、`jmap` 监控 GC 情况

**safe-room 项目 JVM 配置**：

Docker 环境（`docker-compose.yml`）：
```yaml
environment:
  JAVA_OPTS: ${JAVA_OPTS:--Xmx512m -Xms256m}
```

生产环境建议配置：
```bash
# 基础配置
-Xms512m                    # 初始堆内存
-Xmx2048m                   # 最大堆内存
-XX:+UseG1GC                # 使用G1垃圾收集器
-XX:MaxGCPauseMillis=200    # 最大GC暂停时间（毫秒）

# G1 GC 优化参数
-XX:G1HeapRegionSize=16m    # G1区域大小
-XX:InitiatingHeapOccupancyPercent=45  # 触发并发GC的堆占用率

# 元空间配置
-XX:MetaspaceSize=256m      # 元空间初始大小
-XX:MaxMetaspaceSize=512m   # 元空间最大大小

# GC日志
-Xlog:gc*:file=/app/logs/gc.log:time,level,tags:filecount=10,filesize=10M

# 其他优化
-XX:+HeapDumpOnOutOfMemoryError  # OOM时生成堆转储
-XX:HeapDumpPath=/app/logs/heapdump.hprof
-XX:+UseStringDeduplication      # 字符串去重（G1）
```

**配置建议**：
- 小规模部署（< 4GB 内存）：`-Xmx512m -Xms256m -XX:+UseG1GC`
- 中等规模（4-8GB 内存）：`-Xmx2048m -Xms1024m -XX:+UseG1GC`
- 大规模（> 8GB 内存）：`-Xmx4096m -Xms2048m -XX:+UseG1GC` 或考虑 ZGC

#### 5.3.2 数据库调优
- **PostgreSQL 配置**：
  - `shared_buffers`：共享缓冲区大小
  - `work_mem`：工作内存
  - `maintenance_work_mem`：维护工作内存
  - `effective_cache_size`：有效缓存大小
- **定期维护**：`VACUUM`、`ANALYZE`、`REINDEX`

#### 5.3.3 网络优化
- **HTTP/2**：使用 HTTP/2 协议，支持多路复用
- **压缩**：启用 gzip/deflate 压缩
- **Keep-Alive**：保持连接，减少握手开销
- **CDN**：静态资源使用 CDN 加速

### 5.4 前端性能优化

#### 5.4.1 资源优化
- **代码分割**：使用 Vite 的路由懒加载、动态导入
- **Tree Shaking**：移除未使用的代码
- **压缩**：压缩 JS、CSS 文件
- **图片优化**：使用 WebP/AVIF 格式，懒加载

**safe-room 项目前端优化实践**：

1. **Vite 构建配置**（`vite.config.ts`）：
```typescript
export default defineConfig({
  build: {
    outDir: 'dist',
    assetsDir: 'assets',
    sourcemap: !isProd,              // 生产环境关闭sourcemap
    chunkSizeWarningLimit: 1500,     // chunk大小警告阈值（KB）
    rollupOptions: {
      output: {
        // 代码分割：按chunk名称和hash命名
        chunkFileNames: 'assets/js/[name]-[hash].js',
        entryFileNames: 'assets/js/[name]-[hash].js',
        assetFileNames: 'assets/[ext]/[name]-[hash].[ext]',
        // 手动分割大依赖
        manualChunks: {
          'vue-vendor': ['vue', 'vue-router', 'pinia'],
          'element-plus': ['element-plus'],
          'echarts': ['echarts'],
        },
      },
    },
  },
  // 依赖预构建优化
  optimizeDeps: {
    exclude: ['vue-demi'],
    include: ['element-plus', 'axios'],
  },
})
```

2. **路由懒加载**（`router/index.ts`）：
```typescript
// 使用动态导入实现路由懒加载
const yonghuList = () => import('../pages/yonghu/list.vue')
const jianshenkechengList = () => import('../pages/jianshenkecheng/list.vue')
const jianshenjiaolianList = () => import('../pages/jianshenjiaolian/list.vue')

// 组件懒加载
const CoachNetwork = defineAsyncComponent(() => 
  import('@/components/home/CoachNetwork.vue')
)
```

3. **Element Plus 按需引入**：
```typescript
// 使用 unplugin-vue-components 自动按需引入
Components({
  resolvers: [ElementPlusResolver()],
  dts: true,  // 生成类型定义文件
})
```

4. **性能优化效果**：
- 首屏加载时间：< 2秒
- 代码分割后，单个chunk大小：< 500KB
- Tree Shaking 减少 bundle 体积：约 30-40%

#### 5.4.2 渲染优化
- **虚拟滚动**：长列表使用虚拟滚动
- **防抖节流**：输入框、滚动事件使用防抖节流
- **requestIdleCallback**：在空闲时间执行非关键任务
- **Intersection Observer**：图片懒加载、无限滚动

#### 5.4.3 缓存策略
- **浏览器缓存**：设置合理的缓存头
- **Service Worker**：离线缓存、后台同步
- **LocalStorage**：缓存用户数据、配置信息

---

## 第六章：分布式系统性能

### 6.1 分布式系统性能挑战

#### 6.1.1 网络延迟
- **问题**：服务间调用增加网络延迟
- **影响**：响应时间增加，用户体验下降
- **优化**：减少服务调用次数，使用异步调用，批量处理

#### 6.1.2 数据一致性
- **问题**：分布式环境下保证数据一致性困难
- **影响**：可能出现数据不一致，影响业务逻辑
- **解决方案**：
  - **强一致性**：使用分布式事务（2PC、3PC、TCC）
  - **最终一致性**：使用消息队列、事件溯源

#### 6.1.3 服务依赖
- **问题**：服务间依赖复杂，一个服务故障可能影响整个系统
- **影响**：系统可用性下降
- **解决方案**：服务降级、熔断、限流

### 6.2 微服务性能优化

#### 6.2.1 服务拆分
- **原则**：按业务领域拆分，保持服务独立性
- **粒度**：避免过度拆分，平衡性能和复杂度
- **通信**：选择合适的通信方式（同步 HTTP、异步消息）

#### 6.2.2 API 网关
- **功能**：统一入口、路由、认证、限流、监控
- **优势**：减少客户端与服务的耦合，统一处理横切关注点
- **实现**：Spring Cloud Gateway、Kong、Nginx

#### 6.2.3 服务发现
- **功能**：自动发现和注册服务
- **实现**：Consul、Eureka、Nacos
- **优化**：使用本地缓存，减少服务发现调用

### 6.3 分布式缓存策略

#### 6.3.1 缓存一致性
- **问题**：多实例部署时缓存更新不一致
- **解决方案**：
  - **Cache-Aside**：应用层控制缓存更新
  - **Write-Through**：同时更新缓存和数据库
  - **失效策略**：使用消息队列通知缓存失效

#### 6.3.2 缓存穿透
- **问题**：查询不存在的数据，绕过缓存直接查数据库
- **解决方案**：
  - **布隆过滤器**：快速判断数据是否存在
  - **缓存空值**：对不存在的数据也缓存，设置短 TTL

#### 6.3.3 缓存击穿
- **问题**：热点数据过期，大量请求同时访问数据库
- **解决方案**：
  - **互斥锁**：使用分布式锁，只允许一个请求查数据库
  - **永不过期**：热点数据设置永不过期，异步更新

#### 6.3.4 缓存雪崩
- **问题**：大量缓存同时过期，请求全部打到数据库
- **解决方案**：
  - **随机过期时间**：避免缓存同时过期
  - **多级缓存**：本地缓存 + 分布式缓存
  - **限流降级**：缓存失效时使用限流保护数据库

### 6.4 消息队列性能优化

#### 6.4.1 消息队列选择
- **RabbitMQ**：功能全面，支持多种消息模式
- **Kafka**：高吞吐量，适合日志、流处理
- **RocketMQ**：阿里开源，适合电商场景
- **Redis Stream**：轻量级，适合简单场景

#### 6.4.2 性能优化
- **批量发送**：批量发送消息，减少网络开销
- **异步消费**：使用异步消费，提高吞吐量
- **分区策略**：合理设置分区数，提高并行度
- **消息压缩**：压缩消息内容，减少网络传输

---

## 第七章：性能测试实践

### 7.1 测试计划制定

#### 7.1.1 测试目标
- **性能指标**：明确响应时间、吞吐量、并发数等目标
- **测试范围**：确定要测试的功能模块
- **测试环境**：准备与生产环境相似的测试环境
- **资源准备**：准备测试工具、测试数据、监控工具

#### 7.1.2 测试场景设计
- **典型场景**：正常业务场景的性能测试
- **峰值场景**：业务高峰期的性能测试
- **压力场景**：超出正常负载的压力测试
- **稳定性场景**：长时间运行的稳定性测试

### 7.2 测试场景设计

#### 7.2.1 业务场景
- **课程浏览**：模拟用户浏览课程列表、查看课程详情
- **课程预约**：模拟用户预约课程，测试并发预约
- **支付流程**：模拟支付流程，测试支付性能
- **会员管理**：模拟会员注册、登录、信息查询

#### 7.2.2 负载模型
- **阶梯式增长**：逐步增加并发用户数
- **波浪式增长**：模拟业务高峰和低谷
- **突发式增长**：模拟突发流量
- **长时间运行**：测试系统长时间运行的稳定性

### 7.3 测试执行与结果分析

#### 7.3.1 测试执行
- **环境准备**：确保测试环境稳定，数据准备充分
- **监控配置**：配置性能监控工具，收集指标数据
- **执行测试**：按照测试计划执行测试
- **数据收集**：收集响应时间、吞吐量、错误率等数据

#### 7.3.2 结果分析
- **响应时间分析**：分析 P50、P95、P99 响应时间
- **吞吐量分析**：分析系统最大吞吐量
- **错误分析**：分析错误类型和错误率
- **资源分析**：分析 CPU、内存、磁盘、网络使用情况

#### 7.3.3 瓶颈识别
- **前端瓶颈**：页面加载慢、资源加载慢
- **后端瓶颈**：接口响应慢、处理能力不足
- **数据库瓶颈**：查询慢、连接数不足
- **网络瓶颈**：带宽不足、延迟高

### 7.4 性能回归测试

#### 7.4.1 回归测试策略
- **自动化**：将性能测试集成到 CI/CD 流程
- **基准测试**：建立性能基准，每次发布对比
- **阈值告警**：性能下降超过阈值时告警
- **趋势分析**：分析性能趋势，提前发现问题

#### 7.4.2 持续监控
- **生产监控**：在生产环境持续监控性能指标
- **告警机制**：设置性能告警阈值
- **定期报告**：定期生成性能报告，分析趋势

---

## 第八章：容量规划

### 8.1 容量规划方法

#### 8.1.1 基于历史数据
- **数据分析**：分析历史流量数据，预测未来需求
- **趋势分析**：识别流量增长趋势
- **季节性分析**：考虑业务季节性波动

#### 8.1.2 基于业务目标
- **业务规划**：根据业务目标估算流量
- **用户增长**：根据用户增长计划估算容量需求
- **活动规划**：考虑促销活动等特殊场景

#### 8.1.3 压力测试验证
- **容量测试**：通过压力测试确定系统容量
- **瓶颈分析**：识别系统瓶颈，确定扩容方案
- **验证优化**：验证优化效果，调整容量规划

### 8.2 资源需求评估

#### 8.2.1 计算资源
- **CPU**：根据 QPS 和单请求 CPU 消耗计算
- **内存**：根据并发用户数和单用户内存消耗计算
- **存储**：根据数据增长速度和保留策略计算

#### 8.2.2 网络资源
- **带宽**：根据请求大小和 QPS 计算
- **连接数**：根据并发用户数计算
- **CDN**：根据静态资源大小和访问量计算

#### 8.2.3 数据库资源
- **连接数**：根据应用实例数和连接池配置计算
- **存储空间**：根据数据增长速度和保留策略计算
- **读写分离**：根据读写比例规划主从配置

### 8.3 扩展性设计

#### 8.3.1 水平扩展
- **无状态设计**：应用无状态，支持水平扩展
- **负载均衡**：使用负载均衡器分发请求
- **数据分片**：数据量大时考虑分库分表

#### 8.3.2 垂直扩展
- **硬件升级**：升级 CPU、内存、磁盘
- **适用场景**：单机性能瓶颈，无法水平扩展
- **限制**：硬件升级有上限，成本高

#### 8.3.3 弹性扩展
- **自动扩缩容**：根据负载自动调整实例数
- **云原生**：使用 Kubernetes、云服务实现弹性扩展
- **成本优化**：按需扩容，节省成本

### 8.4 成本优化

#### 8.4.1 资源优化
- **资源利用率**：提高资源利用率，避免资源浪费
- **按需分配**：根据实际需求分配资源
- **定期评估**：定期评估资源使用情况，调整配置

#### 8.4.2 架构优化
- **缓存策略**：合理使用缓存，减少数据库压力
- **CDN**：使用 CDN 减少服务器负载
- **异步处理**：使用消息队列异步处理，提高吞吐量

#### 8.4.3 成本监控
- **成本分析**：定期分析资源成本
- **优化建议**：根据成本分析提出优化建议
- **预算控制**：设置成本预算，超预算时告警

---

## 附录：性能工程检查清单

### 开发阶段
- [ ] 代码审查时检查性能问题
- [ ] 使用合适的算法和数据结构
- [ ] 避免 N+1 查询问题
- [ ] 合理使用缓存
- [ ] 优化数据库查询

### 测试阶段
- [ ] 制定性能测试计划
- [ ] 执行压力测试
- [ ] 分析性能测试结果
- [ ] 识别和修复性能瓶颈

### 部署阶段
- [ ] 配置性能监控
- [ ] 设置性能告警阈值
- [ ] 优化 JVM 参数
- [ ] 优化数据库配置

### 运维阶段
- [ ] 持续监控性能指标
- [ ] 定期分析性能趋势
- [ ] 根据监控数据优化系统
- [ ] 定期进行容量规划

---

## 参考文档

- [系统架构文档](ARCHITECTURE.md)
- [最佳实践文档](BEST_PRACTICES.md)
- [API 文档](API.md)
- [数据库文档](DATABASE.md)
- [安全文档](SECURITY.md)
- [部署文档](../DEPLOYMENT.md)
- [测试文档](../TESTING.md)

---

## 更新记录

| 日期 | 版本 | 更新内容 | 作者 |
|------|------|---------|------|
| 2024-XX-XX | 1.0 | 初始版本，创建性能工程总章大纲 | - |

---

